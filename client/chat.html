<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ç§äººåŠ©æ‰‹BOT å¯¹è¯</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <style>
    /* å¸ƒå±€å£³ä¸ä¾§æ ï¼ˆæ›´çª„ï¼‰ */
    .chat-shell { display: flex; gap: 0; height: calc(100vh - 140px); min-height: 560px; background: #fff; border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.06); overflow: hidden; }
    .sidebar { width: 260px; background: #fafafa; border-right: 1px solid #eee; }
    .sidebar .header { padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; }
    .conv-list { height: calc(100% - 48px); overflow-y: auto; padding: 8px 8px 12px; }
    .conv-item { border: none; background: transparent; padding: 10px 12px; border-radius: 12px; margin-bottom: 6px; cursor: pointer; }
    .conv-item:hover { background: #fff; box-shadow: 0 6px 16px rgba(0,0,0,0.08); }
    .conv-item.active { background: #eaf2ff; box-shadow: inset 0 0 0 1px #cfe0ff; }

    /* å³ä¾§é¢æ¿ä¸å¤´éƒ¨ */
    .panel { flex: 1; display: flex; flex-direction: column; }
    .panel-header { padding: 16px 24px; border-bottom: 1px solid #eee; }
    .panel-title { font-weight: 600; color: #333; }

    /* QQ é£æ ¼èŠå¤©æ°”æ³¡ä¸æ»šåŠ¨åŒºåŸŸï¼ˆåˆå¹¶ä¸ºå£³å†…ä¸€ä½“ï¼‰ */
    .chat-window {
      flex: 1;
      min-height: 420px;
      overflow-y: auto;
      padding: 24px;
      background: #fff;
      scroll-behavior: smooth;
    }
    .hero-welcome { text-align: center; color: #555; font-size: 18px; padding: 40px 0; }
    .message-row { display: flex; margin-bottom: 10px; }
    .message-row.assistant { justify-content: flex-start; }
    .message-row.user { justify-content: flex-end; }
    .bubble { max-width: 70%; padding: 10px 12px; border-radius: 16px; position: relative; white-space: pre-wrap; word-break: break-word; line-height: 1.5; }
    .bubble.assistant { background: #fff; border: 1px solid #e5e7eb; color: #222; border-top-left-radius: 6px; }
    .bubble.user { background: #1677ff; color: #fff; border-top-right-radius: 6px; }
    .bubble.assistant::after { content: ""; position: absolute; left: -6px; top: 12px; width: 0; height: 0; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-right: 6px solid #fff; }
    .bubble.user::after { content: ""; position: absolute; right: -6px; top: 12px; width: 0; height: 0; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-left: 6px solid #1677ff; }

    /* è¾“å…¥åŒºï¼šåœ†è§’æ°”æ³¡ä¸å‘é€åœ†é’® */
    .composer { background: #fff; padding: 16px 20px; border-top: 1px solid #eee; }
    .input-bubble { display: flex; align-items: center; gap: 10px; padding: 8px 12px; border: 1px solid #e5e7eb; border-radius: 20px; background: #fff; box-shadow: 0 4px 12px rgba(0,0,0,0.04); }
    .input-bubble textarea { border: 0; outline: none; resize: none; flex: 1; height: 36px; line-height: 1.4; }
    .input-bubble .btn-sm { display: inline-flex; align-items: center; height: 36px; padding: 0 12px; }
    .send-circle { width: 36px; height: 36px; border-radius: 18px; background: #1677ff; color: #fff; display: flex; align-items: center; justify-content: center; font-weight: 700; flex: 0 0 auto; }
    .send-circle:disabled { opacity: .6; cursor: not-allowed; }
    /* æ·»åŠ å›¾ç‰‡ç¼©ç•¥æ˜¾ç¤º */
    .thumbs { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .thumbs .thumb { position:relative; width:56px; height:56px; border-radius:12px; overflow:hidden; border:1px solid rgba(255,255,255,0.15); }
    .thumbs .thumb img { width:100%; height:100%; object-fit:cover; border-radius:12px; }
    .thumbs .thumb .remove { position:absolute; top:2px; right:4px; background:rgba(0,0,0,0.6); color:#fff; border:none; border-radius:8px; padding:0 4px; cursor:pointer; font-size:12px; }
    /* ç»Ÿä¸€æŒ‰é’®åœ†è§’é£æ ¼ */
    .btn { border-radius: 12px; }
    /* å†å²é€‰æ‹©å™¨ */
    #uploadHistory { margin-top:8px; }
    #uploadHistory .item { display:inline-block; margin-right:8px; margin-bottom:8px; padding:4px 8px; background:#f1f5f9; border-radius:8px; cursor:pointer; }
  </style>
</head>
<body>
  <!-- ç»Ÿä¸€å¯¼èˆªï¼šå…¬å…± header ç‰‡æ®µæ³¨å…¥å®¹å™¨ -->
  <div id="header-root"></div>

  <main class="container py-4">
    <div class="chat-shell">
      <aside class="sidebar">
        <div class="header">
          <h6 class="mb-0">èŠå¤©è®°å½•</h6>
          <button id="newConvBtn" class="btn btn-sm btn-primary">æ–°å»ºå¯¹è¯</button>
        </div>
        <ul id="convList" class="list-group conv-list"></ul>
      </aside>
      <section class="panel">
        <div class="panel-header">
          <div class="panel-title">ä»Šå¤©æœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©ä½ ï¼Ÿ</div>
          <div id="sharedStatus" class="alert alert-info d-none mt-2 mb-0" role="alert"></div>
          <div id="chatAlert" class="alert alert-danger d-none mt-2 mb-0" role="alert"></div>
        </div>
        <div id="chatWindow" class="chat-window"></div>
        <div class="composer">
          <div class="input-bubble">
            <button id="addImgBtn" class="btn btn-sm btn-outline-secondary d-none" title="æ·»åŠ å›¾ç‰‡URL">ğŸ–¼ï¸URL</button>
            <button id="uploadBtn" class="btn btn-sm btn-outline-secondary" title="ä¸Šä¼ æœ¬åœ°å›¾ç‰‡">ğŸ“ä¸Šä¼ </button>
            <button id="historyBtn" class="btn btn-sm btn-outline-secondary" title="é€‰æ‹©å†å²ä¸Šä¼ ">ğŸ•˜å†å²</button>
            <textarea id="prompt" rows="2" placeholder="ç»™ DeepSeek å‘æ¶ˆæ¯...\næŒ‰ Enter å‘é€ï¼ŒShift+Enter æ¢è¡Œ"></textarea>
            <button id="sendBtn" class="send-circle" title="å‘é€">â†—</button>
            <button id="stopBtn" class="btn btn-sm btn-outline-danger" title="ç»ˆæ­¢å›å¤" disabled>â¹ ç»ˆæ­¢</button>
            <input type="file" id="fileInput" accept="image/*" multiple hidden />
          </div>
          <div id="urlInputBox" class="mt-2 d-none">
            <input id="urlInput" type="text" class="form-control form-control-sm" placeholder="è¾“å…¥å›¾ç‰‡URLï¼ˆhttp/https æˆ– data URLï¼‰" />
            <div class="mt-1">
              <button id="urlConfirmBtn" class="btn btn-sm btn-primary me-2">æ·»åŠ </button>
              <button id="urlCancelBtn" class="btn btn-sm btn-secondary">å–æ¶ˆ</button>
            </div>
          </div>
          <div id="thumbs" class="thumbs mt-2"></div>
          <div id="uploadHistory" class="mt-1"></div>
        </div>
      </section>
    </div>
  </main>

  <script type="module">
    import { ensureAuth } from './js/auth.js';
    import { request, requestForm, getToken, getCsrfToken } from './js/api.js';
    import { injectHeader } from './js/header.js';

    const user = await ensureAuth();
    // æ³¨å…¥ç»Ÿä¸€å¯¼èˆªï¼ˆè‡ªåŠ¨æ ‡è®° activeï¼Œå¤„ç† Admin æ˜¾ç¤ºä¸ç™»å‡ºï¼‰
    await injectHeader();

    const chatAlert = document.getElementById('chatAlert');
    const sharedStatusEl = document.getElementById('sharedStatus');
    const chatWindow = document.getElementById('chatWindow');
    const promptEl = document.getElementById('prompt');
    const sendBtn = document.getElementById('sendBtn');
    const stopBtn = document.getElementById('stopBtn');
    let isStreaming = false;
    let currentStreamCtrl = null;
    const convListEl = document.getElementById('convList');
    const newConvBtn = document.getElementById('newConvBtn');
    const fileInput = document.getElementById('fileInput');
    const uploadBtn = document.getElementById('uploadBtn');
    const historyBtn = document.getElementById('historyBtn');

    let currentConversationId = null;
    let conversations = [];
    let messages = [];
    let attachments = [];

    function setAlert(msg) {
      if (!msg) { chatAlert.classList.add('d-none'); chatAlert.textContent = ''; return; }
      chatAlert.classList.remove('d-none'); chatAlert.textContent = msg;
    }

    function getTuningSettings() {
      try {
        const raw = localStorage.getItem('tuningSettings');
        return raw ? (JSON.parse(raw) || {}) : {};
      } catch { return {}; }
    }
    function updateSharedStatus() {
      if (!sharedStatusEl) return;
      const s = getTuningSettings();
      if (s.use_shared && s.shared_key_id) {
        const p = (s.provider || 'deepseek');
        sharedStatusEl.classList.remove('d-none');
        sharedStatusEl.textContent = `ä½¿ç”¨å…±äº«é…ç½®ä¸­ï¼š#${s.shared_key_id} (${p}) â€” å¯åœ¨â€œå…±äº«APIâ€é¡µç®¡ç†`;
      } else {
        sharedStatusEl.classList.add('d-none');
        sharedStatusEl.textContent = '';
      }
    }

    function renderThumbs() {
      const box = document.getElementById('thumbs');
      if (!box) return;
      box.innerHTML = '';
      attachments.forEach((u, i) => {
        const d = document.createElement('div'); d.className = 'thumb';
        const img = document.createElement('img'); img.src = u; d.appendChild(img);
        const rm = document.createElement('button'); rm.className = 'remove'; rm.textContent = 'Ã—'; rm.onclick = () => { attachments.splice(i, 1); renderThumbs(); };
        d.appendChild(rm);
        box.appendChild(d);
      });
    }

    const urlBox = document.getElementById('urlInputBox');
    const urlInput = document.getElementById('urlInput');
    const urlConfirmBtn = document.getElementById('urlConfirmBtn');
    const urlCancelBtn = document.getElementById('urlCancelBtn');

    document.getElementById('addImgBtn').addEventListener('click', () => {
      urlBox.classList.remove('d-none');
      urlInput.value = '';
      urlInput.focus();
    });
    urlConfirmBtn.addEventListener('click', () => {
      const u = (urlInput.value || '').trim();
      if (!u) return;
      const ok = /^(https?:\/\/|data:image\/.+;base64,)/i.test(u);
      if (!ok) { setAlert('URL æ ¼å¼ä¸æ­£ç¡®'); return; }
      attachments.push(u); renderThumbs();
      urlBox.classList.add('d-none');
    });
    urlCancelBtn.addEventListener('click', () => {
      urlBox.classList.add('d-none');
    });
    urlInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); urlConfirmBtn.click(); }
    });

    uploadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', async () => {
      if (!fileInput.files || fileInput.files.length === 0) return;
      const fd = new FormData();
      for (const f of fileInput.files) fd.append('files', f);
      try {
        const data = await requestForm('/chat/uploads', fd, 'POST');
        const urls = (data.files || []).map(x => x.url);
        attachments.push(...urls); renderThumbs(); fileInput.value = '';
      } catch (err) { setAlert('ä¸Šä¼ å¤±è´¥ï¼š' + err.message); }
    });

    // åˆå§‹åŒ–å…±äº«é…ç½®çŠ¶æ€æç¤ºï¼Œå¹¶åœ¨æœ¬åœ°å­˜å‚¨å˜åŒ–æ—¶åŒæ­¥
    updateSharedStatus();
    window.addEventListener('storage', (e) => { if (e.key === 'tuningSettings') updateSharedStatus(); });

    historyBtn.addEventListener('click', async () => {
      try {
        const data = await request('/chat/uploads');
        const list = data.files || [];
        const box = document.getElementById('uploadHistory');
        box.innerHTML = '';
        if (!list.length) { box.textContent = 'æš‚æ— å†å²æ–‡ä»¶'; return; }
        list.forEach(item => {
          const span = document.createElement('span'); span.className = 'item'; span.textContent = item.name || item.url;
          span.title = item.url;
          span.onclick = () => { attachments.push(item.url); renderThumbs(); };
          box.appendChild(span);
        });
      } catch (err) {
        setAlert('è·å–å†å²å¤±è´¥ï¼š' + err.message);
      }
    });

    // æ‹–æ‹½ä¸ç²˜è´´ä¸Šä¼ 
    ['dragenter','dragover','drop'].forEach(evt => document.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); }));
    document.addEventListener('drop', async (e) => {
      const items = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : [];
      if (!items || items.length === 0) return;
      const fd = new FormData();
      for (const f of items) fd.append('files', f);
      try { const data = await requestForm('/chat/uploads', fd, 'POST'); const urls = (data.files || []).map(x => x.url); attachments.push(...urls); renderThumbs(); } catch (err) { setAlert('ä¸Šä¼ å¤±è´¥ï¼š' + err.message); }
    });
    promptEl.addEventListener('paste', async (e) => {
      const items = e.clipboardData && e.clipboardData.items ? e.clipboardData.items : [];
      const fd = new FormData(); let has = false;
      for (const it of items) {
        if (it.kind === 'file') { const f = it.getAsFile(); if (f) { fd.append('files', f); has = true; } }
      }
      if (!has) return;
      try { const data = await requestForm('/chat/uploads', fd, 'POST'); const urls = (data.files || []).map(x => x.url); attachments.push(...urls); renderThumbs(); } catch (err) { setAlert('ä¸Šä¼ å¤±è´¥ï¼š' + err.message); }
    });

    function redactCot(text, visible) {
      if (visible) return text;
      if (!text) return text;
      return text
        .replace(/<think>[\s\S]*?<\/think>/gi, '')
        .replace(/^\s*æ€ç»´é“¾[:ï¼š][\s\S]*?(\n|$)/gi, '')
        .replace(/\[æ€ç»´é“¾\][\s\S]*?$/gi, '');
    }

    function renderMessages() {
      chatWindow.innerHTML = '';
      if (!messages || messages.length === 0) {
        const hero = document.createElement('div');
        hero.className = 'hero-welcome';
        hero.textContent = 'ä»Šå¤©æœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©ä½ ï¼Ÿ';
        chatWindow.appendChild(hero);
        return;
      }
      messages.forEach(m => {
        const row = document.createElement('div');
        row.className = 'message-row ' + (m.role === 'user' ? 'user' : 'assistant');
        const bubble = document.createElement('div');
        bubble.className = 'bubble ' + (m.role === 'user' ? 'user' : 'assistant');
        bubble.textContent = m.content || '';
        row.appendChild(bubble);
        // è§£æå¹¶æ˜¾ç¤ºâ€œé™„å›¾:â€ç¼©ç•¥å›¾
        const mt = (m.content || '').match(/é™„å›¾:\s*([^\]]+)/);
        if (mt) {
          const urls = mt[1].split(/[\s,]+/).filter(Boolean);
          if (urls.length) {
            const thumbs = document.createElement('div'); thumbs.className = 'thumbs mt-2';
            urls.forEach(u => { const d = document.createElement('div'); d.className = 'thumb'; const img = document.createElement('img'); img.src = u; d.appendChild(img); thumbs.appendChild(d); });
            row.appendChild(thumbs);
          }
        }
        chatWindow.appendChild(row);
      });
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    async function send() {
      setAlert('');
      const content = promptEl.value.trim();
      if (!content && attachments.length === 0) return;
      sendBtn.disabled = true;

      const effectiveContent = content || '[å›¾ç‰‡]';
      await ensureConversation(effectiveContent);
      // é˜²å¾¡ï¼šè‹¥ä¼šè¯æœªæˆåŠŸåˆ›å»ºï¼Œåˆ™ç»ˆæ­¢å‘é€ï¼Œé¿å…è§¦å‘ /null/send
      if (!currentConversationId) {
        setAlert('ä¼šè¯æœªåˆ›å»ºï¼Œæ— æ³•å‘é€ã€‚è¯·ç¨åé‡è¯•æˆ–æ–°å»ºå¯¹è¯ã€‚');
        sendBtn.disabled = false;
        return;
      }

      const display = effectiveContent + (attachments.length ? `\n[é™„å›¾: ${attachments.join(', ')}]` : '');
      messages.push({ role: 'user', content: display });
      renderMessages();
      promptEl.value = '';

      messages.push({ role: 'assistant', content: 'æ­£åœ¨ç”Ÿæˆå›å¤...' });
      renderMessages();
      try {
        let params = {};
        try { const raw = localStorage.getItem('tuningSettings'); if (raw) params = JSON.parse(raw) || {}; } catch {}
        if (params.stream) {
          isStreaming = true; stopBtn.disabled = false;
          currentStreamCtrl = new AbortController();
          try {
            await sendStream(effectiveContent, params, currentStreamCtrl);
          } finally {
            isStreaming = false; stopBtn.disabled = true; currentStreamCtrl = null;
          }
        } else {
          const data = await request(`/chat/conversations/${currentConversationId}/send`, {
            method: 'POST',
            body: JSON.stringify({ content: effectiveContent, params, images: attachments })
          });
          attachments = []; renderThumbs();
          messages.pop();
          const choices = Array.isArray(data.choices) ? data.choices : [data.reply || ''];
          choices.forEach(ch => {
            const out = redactCot(ch, params.cot_visible !== false);
            messages.push({ role: 'assistant', content: out });
          });
          renderMessages();
        }
      } catch (err) {
        messages.pop(); renderMessages();
        setAlert('è¯·æ±‚å¤±è´¥ï¼š' + err.message);
      } finally {
        sendBtn.disabled = false;
      }
    }

    async function sendStream(effectiveContent, params, controller) {
      // ç›´æ¥ä½¿ç”¨ fetch æ¶ˆè´¹ SSEï¼Œå¯è¢« AbortController ç»ˆæ­¢
      const headers = { 'Content-Type': 'application/json' };
      const token = getToken(); const csrf = getCsrfToken();
      if (token) headers['Authorization'] = `Bearer ${token}`;
      if (csrf) headers['X-CSRF-Token'] = csrf;
      let res;
      try {
        res = await fetch('/api/chat/conversations/' + currentConversationId + '/send', {
          method: 'POST',
          headers,
          body: JSON.stringify({ content: effectiveContent, params, images: attachments }),
          signal: controller?.signal
        });
      } catch (err) {
        // ç»ˆæ­¢ä¸å¼¹é”™ï¼Œä¿ç•™å·²ç”Ÿæˆçš„éƒ¨åˆ†å†…å®¹
        if (err && (err.name === 'AbortError' || String(err.message || '').toLowerCase().includes('aborted'))) {
          return;
        }
        throw err;
      }
      if (!res.ok || !res.body) {
        const t = await res.text(); throw new Error(t || 'SSE è¯·æ±‚å¤±è´¥');
      }

      attachments = []; renderThumbs();
      // ç”¨ reader æŒ‰å¸§è¯»å– SSE æ–‡æœ¬
      const reader = res.body.getReader();
      const decoder = new TextDecoder();
      let buffer = ''; let acc = '';
      const idx = messages.length - 1; // å½“å‰å ä½å›å¤çš„ç´¢å¼•
      let lastPaint = 0;
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const frames = buffer.split('\n\n');
        buffer = frames.pop();
        for (const fr of frames) {
          const line = fr.split('\n').find(l => l.startsWith('data:'));
          if (!line) continue;
          const payload = line.slice(5).trim();
          if (!payload || payload === '[DONE]' || payload === '{}') continue;
          let obj; try { obj = JSON.parse(payload); } catch { obj = null; }
          const delta = obj && obj.delta;
          if (delta) {
            acc += delta;
            const out = redactCot(acc, params.cot_visible !== false);
            messages[idx].content = out;
            const now = performance.now();
            if (now - lastPaint > 30) { renderMessages(); lastPaint = now; }
          }
        }
      }
      // è¯»å®Œæœ€åä¸€å¸§å†æ¸²æŸ“ä¸€æ¬¡
      renderMessages();
    }

    // å·¦ä¾§ä¼šè¯åˆ—è¡¨æ¸²æŸ“
    function renderConversations() {
      convListEl.innerHTML = '';
      conversations.forEach(c => {
        const li = document.createElement('li');
        li.className = 'conv-item list-group-item d-flex justify-content-between align-items-center';
        li.dataset.id = String(c.id);
        const name = document.createElement('span');
        name.className = 'conv-title text-truncate';
        name.textContent = c.title || ('ä¼šè¯ #' + c.id);
        const actions = document.createElement('div');
        actions.className = 'conv-actions d-flex gap-2';
        const renameBtn = document.createElement('button');
        renameBtn.className = 'btn btn-sm btn-outline-secondary rename-btn';
        renameBtn.textContent = 'é‡å‘½å';
        renameBtn.title = 'é‡å‘½åæ­¤å¯¹è¯';
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'btn btn-sm btn-outline-danger delete-btn';
        deleteBtn.textContent = 'åˆ é™¤';
        deleteBtn.title = 'åˆ é™¤æ­¤å¯¹è¯';
        actions.appendChild(renameBtn);
        actions.appendChild(deleteBtn);
        li.appendChild(name);
        li.appendChild(actions);
        if (c.id === currentConversationId) li.classList.add('active');
        convListEl.appendChild(li);
      });
    }

    async function loadConversations() {
      try {
        const data = await request('/chat/conversations');
        conversations = data.conversations || [];
        renderConversations();
        if (!currentConversationId && conversations.length > 0) {
          selectConversation(conversations[0].id);
        }
      } catch (err) {
        console.warn('åŠ è½½ä¼šè¯å¤±è´¥ï¼š', err);
      }
    }

    async function loadMessages() {
      if (!currentConversationId) { messages = []; renderMessages(); return; }
      try {
        const data = await request(`/chat/conversations/${currentConversationId}/messages`);
        messages = (data.messages || []).map(m => ({ role: m.role, content: m.content }));
        renderMessages();
      } catch (err) {
        setAlert('åŠ è½½æ¶ˆæ¯å¤±è´¥ï¼š' + err.message);
      }
    }

    function selectConversation(id) {
      currentConversationId = Number(id);
      renderConversations();
      loadMessages();
    }

    async function ensureConversation(firstContent) {
      if (currentConversationId) return;
      const title = (firstContent || 'æ–°å»ºå¯¹è¯').slice(0, 20);
      try {
        const data = await request('/chat/conversations', { method: 'POST', body: JSON.stringify({ title }) });
        currentConversationId = data.id;
        conversations = [{ id: data.id, title, created_at: new Date().toISOString() }, ...conversations];
        renderConversations();
      } catch (err) {
        setAlert('åˆ›å»ºä¼šè¯å¤±è´¥ï¼š' + err.message);
      }
    }

    sendBtn.addEventListener('click', send);
    stopBtn.addEventListener('click', () => { if (currentStreamCtrl) { currentStreamCtrl.abort(); } });
    // Enter å‘é€ï¼ŒShift+Enter æ¢è¡Œ
    promptEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        send();
      }
    });

    // å·¦ä¾§ç‚¹å‡»åˆ‡æ¢ä¼šè¯
    convListEl.addEventListener('click', (e) => {
      const li = e.target.closest('li');
      if (!li) return;
      const id = li.getAttribute('data-id');
      if (!id) return;
      if (e.target.closest('.rename-btn')) { renameConversation(id); return; }
      if (e.target.closest('.delete-btn')) { deleteConversation(id); return; }
      selectConversation(id);
    });

    async function renameConversation(id) {
      try {
        const current = conversations.find(x => String(x.id) === String(id));
        const input = prompt('è¯·è¾“å…¥æ–°çš„å¯¹è¯æ ‡é¢˜ï¼ˆæœ€å¤š100å­—ï¼‰', (current && current.title) || '');
        if (input === null) return; // å–æ¶ˆ
        const title = String(input).trim().slice(0, 100);
        if (!title) { setAlert('æ ‡é¢˜ä¸èƒ½ä¸ºç©º'); return; }
        await request(`/chat/conversations/${id}`, { method: 'PUT', body: JSON.stringify({ title }) });
        const idx = conversations.findIndex(x => String(x.id) === String(id));
        if (idx >= 0) { conversations[idx].title = title; }
        renderConversations();
      } catch (err) {
        setAlert('é‡å‘½åå¤±è´¥ï¼š' + err.message);
      }
    }

    async function deleteConversation(id) {
      try {
        const ok = confirm('ç¡®è®¤åˆ é™¤è¯¥å¯¹è¯ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚');
        if (!ok) return;
        await request(`/chat/conversations/${id}`, { method: 'DELETE' });
        // ä»æœ¬åœ°åˆ—è¡¨ç§»é™¤
        conversations = conversations.filter(x => String(x.id) !== String(id));
        // è‹¥åˆ é™¤å½“å‰ä¼šè¯ï¼Œæ¸…ç©ºå³ä¾§æ¶ˆæ¯
        if (Number(id) === currentConversationId) {
          currentConversationId = null;
          messages = [];
          renderMessages();
        }
        renderConversations();
        // è‹¥è¿˜æœ‰ä¼šè¯ï¼Œé€‰ä¸­ç¬¬ä¸€ä¸ªï¼Œä¿æŒä½“éªŒè¿ç»­
        if (!currentConversationId && conversations.length > 0) {
          selectConversation(conversations[0].id);
        }
      } catch (err) {
        setAlert('åˆ é™¤å¤±è´¥ï¼š' + err.message);
      }
    }

    // æ–°å»ºå¯¹è¯æŒ‰é’®
    newConvBtn.addEventListener('click', async () => {
      try {
        const data = await request('/chat/conversations', { method: 'POST', body: JSON.stringify({ title: 'æ–°å»ºå¯¹è¯' }) });
        currentConversationId = data.id;
        await loadConversations();
        selectConversation(data.id);
      } catch (err) {
        setAlert('æ–°å»ºä¼šè¯å¤±è´¥ï¼š' + err.message);
      }
    });

    await loadConversations();
    renderMessages();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>